\section{Discretization and code framework}
\label{sec:framework}
\subsection{Discretization}
In the following, we discretize the moment system in space and time according to \cite{kusch2017maximum}. Due to the fact, that stochastic-Galerkin can be interpreted as IPM with a quadratic entropy, it suffices to only derive a discretization of the IPM moment system \eqref{eq:IPMmomentSystem}.  
Omitting initial conditions and assuming a one-dimensional spatial domain, we can write this system  as
\begin{align*}
\partial_t \bm{\hat u}+\partial_x \bm{F}(\bm{\hat u}) = \bm{0}
\end{align*}
with the flux $\bm{F}:\mathbb{R}^{(N+1)\times p}\to\mathbb{R}^{(N+1)\times p}$, $\bm{F}(\bm{\hat u})=\langle \bm f(\mathcal{U}(\bm{\hat u}))\bm{\varphi}^T \rangle^T$. Due to hyperbolicity of the IPM moment system, one can use a finite-volume method to approximate the time evolution of the IPM moments. First we perform the discretization of the spatial domain: We choose the discrete unknowns which represent the solution to be the spatial averages over each cell at time $t_n$, given by
\begin{align*}
\bm{\hat u}_{ij}^n \simeq \frac{1}{\Delta x}\int_{x_{j-1/ 2}}^{x_{j+1/ 2}}\bm{\hat u}_i(t_n,x) dx.
\end{align*}
If a moment vector in cell $j$ at time $t_n$ is denoted as $\bm{\hat u}_j^n = (\bm{\hat u}_{0j}^n,\cdots,\bm{\hat u}_{Nj}^n)^T\in\mathbb{R}^{N+1}$, the finite-volume scheme can be written in conservative form with the numerical flux $\bm{G}:\mathbb{R}^{(N+1)\times p}\times\mathbb{R}^{(N+1)\times p}\to\mathbb{R}^{(N+1)\times p}$ as
\begin{align}\label{eq:IPMDiscretization}
\bm{\hat u}_{j}^{n+1} = \bm{\hat u}_{j}^{n}  - \frac{\Delta t}{\Delta x}\left( \bm{G}(\bm{\hat u}_{j}^{n},\bm{\hat u}_{j+1}^{n})- \bm{G}(\bm{\hat u}_{j-1}^{n},\bm{\hat u}_{j}^{n})\right)
\end{align}
for $j = 1,\cdots,N_x$ and $n = 0,\cdots,N_t$, where $N_x$ is the number of spatial cells and $N_t$ is the number of time steps.
The numerical flux is assumed to be consistent, i.e. $\bm{G}(\hat{\bm{u}},\hat{\bm{u}})=\bm{F}(\hat{\bm{u}})$.

When a consistent numerical flux $\bm g:\mathbb{R}^p\times\mathbb{R}^p\to\mathbb{R}^p$, $\bm g = \bm g(\bm u_\ell, \bm u_r)$ is available for the original problem \eqref{eq:hyperbolicProblem}, then for the IPM system we can simply take
\begin{align*}
 \bm{G}(\bm{\hat u}_{j}^n,\bm{\hat u}_{j+1}^{n}) = \langle \bm g(\mathcal{U}(\bm{\hat u}_j^n),\mathcal{U}(\bm{\hat u}_{j+1}^n))\bm{\varphi}^T\rangle^T.
\end{align*}
Note that the numerical flux requires evaluating the closure $\mathcal{U}(\bm{\hat u}_j^n)$. To simplify notation, we define $\bm{u}_{s}:\mathbb{R}^s \to \mathbb{R}^s$,
\begin{align*}
\bm{u}_{s}(\bm\Lambda):=\left( \nabla_{\bm{u}} s \right)^{-1}(\bm\Lambda),
\end{align*}
meaning that the closure \eqref{eq:ansatz} at cell $j$ in timestep $n$ can be written as
\begin{align*}
\mathcal{U}(\bm{\hat u}_j^n) = \bm{u}_{s}(\bm{\hat{\lambda}}(\bm{\hat u}_j^n)^T \bm{\varphi}).
\end{align*}
The computation of the so called entropy variables $\bm{\hat\lambda}_j^n:=\bm{\hat\lambda}(\bm{\hat u}_j^n)$ requires solving the dual problem \eqref{eq:dualProblem} for the moment vector $\bm{\hat u}_{j}^{n}$. Hence, to determine the dual variables for a given moment vector $\bm{\hat{u}}$, the cost function
\begin{align*}
L(\bm{\lambda};\bm{\hat{u}}) := \langle s_*(\bm{\lambda}^T \bm\varphi)\rangle - \sum_{i=0}^{N}\bm{\lambda}_i^T \bm{\hat u}_i
\end{align*}
needs to be minimized, i.e. one needs to find the root of
\begin{align*}
\nabla_{\bm{\lambda_i}}L(\bm{\lambda};\bm{\hat{u}}) = \langle \nabla s_*(\bm{\lambda}^T \bm\varphi)\bm\varphi^T\rangle^T - \bm{\hat u}_i,
\end{align*}
which is usually done by an iterative method. Defining the dual iteration function $\bm{d}:\mathbb{R}^{(N+1)\times p}\times\mathbb{R}^{(N+1)\times p}\to\mathbb{R}^{(N+1)\times p}$,
\begin{align*}
\bm{d}(\bm{\lambda},\bm{\hat{u}}):= \bm{\lambda}-\bm{B}(\bm{\lambda})\cdot \left(\langle \bm u_{s}(\bm{\lambda}^T\bm{\varphi})\bm{\varphi}^T\rangle^T-\bm{\hat{u}}\right),
\end{align*}
with an adequate preconditioner $\bm{B}$, the iteration process for spatial cell $j$ is given by
\begin{align}\label{eq:dualIteration1}
\bm{\lambda}^{(m+1)}_j = \bm{d}(\bm{\lambda}_j^{(m)},\bm{\hat{u}_j}).
\end{align}
The exact dual state is then obtained by computing the fix point of $\bm{d}$, meaning that one converges the iteration \eqref{eq:dualIteration1}, i.e. $\bm{\hat\lambda}_j^n:=\bm{\hat\lambda}(\bm{\hat u_j^n})=\lim_{m\rightarrow\infty}\bm{d}(\bm{\lambda}_j^{(m)},\bm{\hat{u}_j^n})$. A common preconditioner is the inverse Hessian of the dual problem, i.e.
\begin{align*}
\bm{B}(\bm{\lambda}) := \langle \nabla \bm{u}_{\bm{s}} (\bm{\lambda}^T\bm{\varphi})\bm{\varphi}\bm{\varphi}^T\rangle^{-T}.
\end{align*}
To obtain a finite number of iterations for the iteration in cell $j$, a stopping criterion 
\begin{align}\label{eq:tauCrit}
\sum_{i=0}^p\left\Vert \nabla_{\bm{\lambda_i}}L(\bm{\lambda}_j^{(m)};\bm{\hat{u}}_j^n) \right\Vert < \tau
\end{align}
is used.

We now write down the entire scheme: To obtain a more compact notation, one defines
\begin{align*}
\bm{c}\left(\bm{\lambda}_{\ell},\bm{\lambda}_c,\bm{\lambda}_r\right):= \langle \bm u_{s}(\bm{\lambda}_c^T\bm{\varphi})\bm{\varphi}^T\rangle^T - \frac{\Delta t}{\Delta x}\left(\langle \bm g(\bm u_{s}(\bm{\lambda}_c^T\bm{\varphi}),\bm u_{s}(\bm{\lambda}_r^T\bm{\varphi}))\bm{\varphi}^T\rangle^T-\langle \bm g(\bm u_{s}(\bm{\lambda}_{\ell}^T\bm{\varphi}),\bm u_{s}(\bm{\lambda}_c^T\bm{\varphi}))\bm{\varphi}^T\rangle^T\right).
\end{align*}
The moment iteration is then given by
\begin{align}\label{eq:momentIteration}
\bm{\hat u}_j^{n+1} = \bm{c}\left(\bm{\hat\lambda}(\bm{\hat u}_{j-1}^n),\bm{\hat\lambda}(\bm{\hat u}_{j}^n),\bm{\hat\lambda}(\bm{\hat u}_{j+1}^n)\right),
\end{align}
where the map from the moment vector to the dual variables, i.e. $\bm{\lambda}(\bm{\hat u}_{j}^n)$, is obtained by iterating
\begin{align}\label{eq:dualIteration}
\bm{\lambda}_j^{(m+1)} = \bm{d}(\bm{\lambda}_{j}^{(m)};\bm{\hat u}_j^{n}).
\end{align}
until condition \eqref{eq:tauCrit} is fulfilled. This gives Algorithm \ref{alg:IPM}.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\For{$j=0$ to $N_x+1$}
\State $\bm{u}_j^0 \leftarrow \frac{1}{\Delta x} \int_{x_{j-1/ 2}}^{x_{j+1/ 2}} \langle u_{\text{IC}}(x, \cdot) \bm{\varphi} \rangle dx$
\EndFor
\For{$n=0$ to $N_t$}
\For{$j=0$ to $N_x+1$}
\State $\bm{\lambda}_j^{(0)} \leftarrow \bm{\hat \lambda}_j^{n}$
\While{\eqref{eq:tauCrit} is violated}
\State $\bm{\lambda}_j^{(m+1)} \leftarrow \bm{d}(\bm{\lambda}_{j}^{(m)};\bm{\hat u}_j^{n})$
\State $m \leftarrow m+1$
\EndWhile
\State $\bm{\hat \lambda}_j^{n+1} \leftarrow \bm{\lambda}_j^{(m)}$
\EndFor
\For{$j=1$ to $N_x$}
\State $\bm{\hat u}_j^{n+1} \leftarrow \bm{c}(\bm{\hat \lambda}_{j-1}^{n+1},\bm{\hat \lambda}_j^{n+1},\bm{\hat \lambda}_{j+1}^{n+1})$
\EndFor
\EndFor
\end{algorithmic}
\caption{IPM implementation}
\label{alg:IPM}
\end{algorithm}

TODO: Extension to 2D $\rightarrow$ triangular meshes

\subsection{Code framework}

TODO: Code structure, why is it easy to include different equations?