 
#include "expliciteuler.h"

ExplicitEuler::ExplicitEuler( Settings* settings, Mesh* mesh ) : TimeSolver( settings, mesh ) {}

void ExplicitEuler::Advance( std::function<void( Matrix&, const Matrix&, const Matrix&, const Vector&, const Vector& )> const& fluxFunc,
                             MatVec& uNew,
                             MatVec& u,
                             MatVec& uQ,
                             double dt ) {
    auto numCells = _mesh->GetNumCells();
    auto cells    = _mesh->GetGrid();
    Matrix ghostCell( _settings->GetNStates(), _settings->GetNQuadPoints() );

#pragma omp parallel for private( ghostCell )
    for( unsigned j = 0; j < numCells; ++j ) {
        Cell* cell     = cells[j];
        auto neighbors = cell->GetNeighborIDs();
        if( cell->IsBoundaryCell() ) {
            if( cell->GetBoundaryType() == BoundaryType::DIRICHLET ) {
                uNew[j] = u[j];
                continue;
            }
            else if( cell->GetBoundaryType() == BoundaryType::NOSLIP ) {
                ghostCell = uQ[j];
                Vector v( 2, 0.0 );
                Vector n = cell->GetBoundaryUnitNormal();
                for( unsigned k = 0; k < uQ[numCells].columns(); ++k ) {
                    v.reset();
                    v[0]              = ghostCell( 1, k ) / ghostCell( 0, k );
                    v[1]              = ghostCell( 2, k ) / ghostCell( 0, k );
                    double vn         = dot( n, v );
                    Vector Vn         = vn * n;
                    Vector Vb         = -Vn + v;
                    double velMagB    = Vb[0] * Vb[0] + Vb[1] * Vb[1];
                    double velMag     = v[0] * v[0] + v[1] * v[1];
                    double rho        = ghostCell( 0, k );
                    ghostCell( 1, k ) = rho * ( Vb[0] );
                    ghostCell( 2, k ) = rho * ( Vb[1] );
                    ghostCell( 3, k ) += rho * 0.5 * ( velMagB - velMag );
                    // debugging
                    if( cell->GetCenter()[0] < 0.024236900731921196 && j == 11848 ) {
                        std::cout << "--------------------------------" << std::endl;
                        std::cout << "n = " << n << std::endl;
                        std::cout << "v = " << v << std::endl;
                        std::cout << "Vb*n = " << dot( n, Vb ) << std::endl;
                    }
                }
            }
            else if( cell->GetBoundaryType() == BoundaryType::SWWALL ) {
                ghostCell = uQ[j];
                Vector v( 2, 0.0 );
                for( unsigned k = 0; k < uQ[numCells].columns(); ++k ) {
                    v[0]              = ghostCell( 1, k ) / ghostCell( 0, k );
                    v[1]              = ghostCell( 2, k ) / ghostCell( 0, k );
                    Vector n          = cell->GetBoundaryUnitNormal();
                    double vn         = dot( n, v );
                    Vector Vn         = vn * n;
                    Vector Vb         = -Vn + v;
                    double rho        = ghostCell( 0, k );
                    ghostCell( 1, k ) = rho * ( Vb[0] );
                    ghostCell( 2, k ) = rho * ( Vb[1] );
                }
            }
        }

        Matrix rhs( u[0].rows(), u[0].columns(), 0.0 );
        std::vector<int> front;
        front.clear();
        front.resize( 0 );
        bool frontCell = false;
        for( unsigned l = 0; l < neighbors.size(); ++l ) {
            if( ( _mesh->GetBoundaryType( j ) == BoundaryType::NOSLIP || _mesh->GetBoundaryType( j ) == BoundaryType::SWWALL ) &&
                neighbors[l] == numCells ) {
                // debugging
                if( cell->GetCenter()[0] < 0.024236900731921196 && j == 11848 ) {
                    std::cout << "--------------------------------" << std::endl;
                    std::cout << "rhs before boundary = " << rhs << std::endl;
                    frontCell = true;
                }
                fluxFunc( rhs, ghostCell, ghostCell, cell->GetUnitNormal( l ), cell->GetNormal( l ) );
                if( frontCell == true ) {
                    std::cout << "rhs after boundary = " << rhs << std::endl;
                    std::cout << "ghost cell = " << ghostCell << std::endl;
                    std::cout << "nUnit = " << cell->GetUnitNormal( l ) << std::endl;
                    std::cout << "n = " << cell->GetNormal( l ) << std::endl;

                    auto u        = ghostCell;
                    auto v        = ghostCell;
                    unsigned k    = 0;
                    auto nUnit    = cell->GetUnitNormal( l );
                    auto n        = cell->GetNormal( l );
                    double _gamma = 1.4;

                    double rhoInv = 1.0 / u( 0, k );
                    double uU     = u( 1, k ) * rhoInv;
                    double vU     = u( 2, k ) * rhoInv;
                    double p      = ( _gamma - 1.0 ) * ( u( 3, k ) - 0.5 * u( 0, k ) * ( pow( uU, 2 ) + pow( vU, 2 ) ) );
                    double aU     = sqrt( _gamma * p * rhoInv );

                    rhoInv    = 1.0 / v( 0, k );
                    double uV = v( 1, k ) * rhoInv;
                    double vV = v( 2, k ) * rhoInv;
                    p         = ( _gamma - 1.0 ) * ( v( 3, k ) - 0.5 * v( 0, k ) * ( pow( uV, 2 ) + pow( vV, 2 ) ) );
                    double aV = sqrt( _gamma * p * rhoInv );

                    double uUProjected = nUnit[0] * uU + nUnit[1] * vU;
                    double uVProjected = nUnit[0] * uV + nUnit[1] * vV;

                    double lambdaMin = uUProjected - aU;
                    double lambdaMax = uVProjected + aV;

                    // flux
                    auto uNew = column( u, k );
                    Matrix flux( uNew.size(), 2 );

                    double rhoInvNew = 1.0 / uNew[0];
                    double v1        = uNew[1] * rhoInvNew;
                    double v2        = uNew[2] * rhoInvNew;

                    flux( 0, 0 ) = uNew[1];
                    flux( 1, 0 ) = uNew[1] * v1 + p;
                    flux( 2, 0 ) = uNew[1] * v2;
                    flux( 3, 0 ) = ( uNew[3] + p ) * v1;
                    flux( 0, 1 ) = uNew[2];
                    flux( 1, 1 ) = uNew[2] * v1;
                    flux( 2, 1 ) = uNew[2] * v2 + p;
                    flux( 3, 1 ) = ( uNew[3] + p ) * v2;

                    std::cout << "mass flux = " << v1 * n[0] + v2 * n[1] << std::endl;

                    std::cout << "boundary flux = " << flux * n << std::endl;

                    std::cout << "cellID = " << j << ", nodes = " << cell->GetNodes()[0]->id << " " << cell->GetNodes()[1]->id << " "
                              << cell->GetNodes()[2]->id << ", center = " << cell->GetCenter() << std::endl;
                    std::cout << "mesh boundaryType = " << _mesh->GetBoundaryType( j ) << std::endl;
                    std::cout << "cell boundaryType = " << cell->GetBoundaryType() << std::endl;
                }
            }
            else {
                fluxFunc( rhs, uQ[j], uQ[neighbors[l]], cell->GetUnitNormal( l ), cell->GetNormal( l ) );
                if( frontCell == true && j == 11848 ) {
                    std::cout << "rhs = " << rhs << std::endl;
                }
            }
        }
        uNew[j] = u[j] - ( dt / cell->GetArea() ) * rhs;
        if( frontCell == true && j == 11848 ) {
            std::cout << "neighbors are " << neighbors << std::endl;
        }
    }
}
